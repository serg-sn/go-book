# Опановування основами Go: Практичний посібник з освоєння мови Go

## Розділ 7. Універсальність та Рефлексія

### 7.1 Універсальності (Generics) в Go
![](assets/chapter_07_01.png)
Універсальність (або Generics) у Go - це функціональність, яка була додана в останніх версіях мови і яка дозволяє писати
функції
та типи, які можуть працювати з різними типами даних, не втрачаючи при цьому безпеку типів.

#### Ключові Концепції Універсальності

1. **Типові Параметри:** Універсальність дозволяє визначати функції та типи з "типовими параметрами". Це означає, що ви
   можете створити шаблон, який буде працювати з будь-яким типом.

2. **Більш Гнучкий Код:** Завдяки універсальності, ви можете створювати більш загальні та многоразові алгоритми та
   структури даних, які можуть бути використані з різними типами.

#### Приклад Універсальної Функції

```go
package main

import "fmt"

// Функція Compare, яка приймає два параметри будь-якого типу (T) і порівнює їх
func Compare[T comparable](a, b T) bool {
	return a == b
}

func main() {
	fmt.Println(Compare(1, 1))             // true
	fmt.Println(Compare("Hello", "World")) // false
}
```

У цьому прикладі, `Compare` є універсальною функцією, яка може порівнювати два значення будь-якого типу, який підтримує
порівняння (означено ключовим словом `comparable`).

#### Користь Універсальності

Універсальність у Go відкриває нові можливості для створення гнучкого та перевикористовуваного коду. Вона особливо
корисна у таких випадках:

- При створенні загальних колекцій, таких як стеки, черги, мапи, тощо.
- При розробці алгоритмів, які можуть працювати з даними різних типів.

Універсальність дозволяє писати код, який є одночасно типобезпечним і гнучким, знижуючи потребу в багаторазовому
написанні однакового коду для різних типів даних.

### 7.1.1 Оголошення та Використання Generic Types

З введенням універсальностей (generics) у Go, можливо оголошувати типи, функції, структури та методи, які можуть
працювати з різними типами даних. Ось як це можна зробити:

#### Оголошення Generic Type

Ви можете оголосити новий generic type, використовуючи синтаксис типових параметрів у квадратних дужках `[]`.

```go
package main

type MyGeneric[T any] struct {
	Values []T
	prev *MyGenericCollection[T]
	next *MyGenericCollection[T]
}
```

Тут `MyGeneric` - це новий тип, який може бути інстанційований з будь-яким типом. Ключове слово `any` вказує, що `T`
може бути будь-яким типом.

#### Використання у Функціях

Generic типи можна використовувати у параметрах та поверненнях функцій:

```go
package main

import "fmt"

func PrintValue[T any](v MyGeneric[T]) {
	fmt.Println(v.Value)
}
```

У цьому прикладі, `PrintValue` є функцією, яка приймає `MyGeneric` тип з будь-яким параметром типу і виводить його
значення.

#### Використання у Структурах

Generic типи можуть бути використані для визначення полів у структурах:

```go
package main

type Container[T any] struct {
	Elements []T
}
```

Тут `Container` - це структура, яка містить слайс елементів будь-якого типу.

#### Методи Структур

Методи також можуть бути визначені для generic типів:

```go
package main

func (c *Container[T]) Add(element T) {
	c.Elements = append(c.Elements, element)
}
```

У цьому випадку, метод `Add` додає новий елемент до контейнера `Container`.

#### Приклад Використання

```go
package main

func main() {
	intContainer := Container[int]{Elements: []int{1, 2, 3}}
	intContainer.Add(4)
	fmt.Println(intContainer.Elements) // Виведе: [1 2 3 4]

	stringContainer := Container[string]{Elements: []string{"Hello", "World"}}
	stringContainer.Add("!")
	fmt.Println(stringContainer.Elements) // Виведе: [Hello World !]
}
```

У цьому прикладі створюються два контейнери: один для `int` та інший для `string`. Демонструється, як один і той же код
може бути використаний для різних типів даних, завдяки універсальностям.

### 7.2 Універсальності та Інтерфейси

У Go, універсальності та інтерфейси можуть взаємодіяти один з одним, створюючи потужний механізм для написання гнучкого
та абстрактного коду. Ця взаємодія дозволяє вам використовувати універсальні типи з інтерфейсами, забезпечуючи більшу
гнучкість та підтримку різноманітних типів.

#### Універсальності з Інтерфейсними Обмеженнями

Універсальності в Go можуть мати обмеження, які визначають, які типи можуть бути використані як типові аргументи. Ці
обмеження можуть бути визначені за допомогою інтерфейсів.

##### Приклад:

```go
package main
typr
type Adder[T any] interface {
	Add(a, b T) T
}

func Sum[T Adder[T]](a, b T) T {
	return a.Add(b)
}
```

У цьому прикладі, `Adder` - це інтерфейс з одним методом `Add`, який визначає операцію додавання для типу `T`.
Функція `Sum` використовує універсальність з інтерфейсним обмеженням `Adder[T]`, що гарантує, що типи, використані з
цією функцією, імплементують метод `Add`.

#### Інтерфейси як Типові Аргументи

Інтерфейси можуть використовуватися як типові аргументи в універсальних функціях або структурах. Це дозволяє вам
створювати функції та структури, які можуть працювати з будь-якими типами, що імплементують певні інтерфейси.

#### Приклад:

```go
package main

import "fmt"

func PrintAll[T fmt.Stringer](items []T) {
	for _, item := range items {
		fmt.Println(item.String())
	}
}

type MyInt int

func (m MyInt) String() string {
	return fmt.Sprintf("MyInt: %d", m)
}

func main() {
	values := []MyInt{1, 2, 3}
	PrintAll(values)
}
```

У цьому прикладі, функція `PrintAll` використовує універсальність з типовим аргументом `fmt.Stringer`, що дозволяє їй
працювати з будь-якими типами, які імплементують метод `String()`.

### Використання Інтерфейсів з Універсальностями

Комбінація універсальностей з інтерфейсами в Go відкриває широкі можливості для створення гнучких та масштабованих
дизайнів програм. Це дозволяє вам створювати код, який може працювати з різними типами даних, але при цьому забезпечує
певну рівень типової безпеки та абстракції.

У Go, інтерфейси можуть використовуватися не тільки для визначення набору методів, але й як спосіб задати обмеження на
типи даних, які можуть бути використані в універсальностях (generics). Це дає змогу обмежити типові параметри певним
набором типів, забезпечуючи більшу гнучкість та контроль над тим, як можуть бути використані універсальні типи.

### 7.1.1 Інтерфейси як Обмеження Типів

Інтерфейси можуть визначати "союз" (union) стандартних типів даних, які можуть бути використані як обмеження для типових
параметрів універсальностей. Це може бути корисно, наприклад, коли ви хочете створити універсальну функцію, яка працює
тільки з числовими типами.

#### Приклад:

Уявімо, що ми хочемо створити функцію, яка працює тільки з цілими числами та числами з плаваючою точкою:

```go
package main

type Number interface {
	~int | float64
}

func Sum[T Number](a, b T) T {
	return a + b
}

```

У цьому прикладі, `Number` - це інтерфейс, який використовується як обмеження типу для параметрів функції `Sum`. Це
означає, що `Sum` може бути викликана тільки з аргументами, які є або будь яким типом на основі `int`, або
строго `float64`.

Зверніть увагу на використання `~int`. Це означає що не тільки тип `int` може бути використано з цим обмеженням, але
також наприклад:

```go
package main

type Number interface {
	~int | float64
}

func Sum[T Number](a, b T) T {
	return a + b
}

type MyInt int

/* some functional here */

func sumInts(a, b MyInt) MyInt { // цей код буде працювати
	return Sum(a, b)
}

type MyFloat float64

/* some functional here */

func sumF(a, b MyFloat) MyFloat { // викличе помилку при компіляції
	return Sum(a, b)
}

```

> Будьте уважні при створенні обмежень зі строгими типами даних, такі обмеження не підтримують власні типи даних на
> основі заданого типу.

#### Використання у Структурах

Такий же підхід може бути застосований і для структур:

```go
package main

type Number interface {
	~int | float64
}

type NumericContainer[T Number] struct {
	value T
}

func (nc *NumericContainer[T]) SetValue(v T) {
	nc.value = v
}

func (nc NumericContainer[T]) GetValue() T {
	return nc.value
}

```

У цьому прикладі, `NumericContainer` - це універсальна структура, яка може містити значення типу сумісного з `int` або
строго `float64`,
відповідно до визначення інтерфейсу `Number`.

#### Застосування

Цей підхід до використання інтерфейсів як обмежень на типи в універсальностях дозволяє створювати більш безпечний та
контрольований код. Він забезпечує, що універсальні типи та функції можуть бути використані лише з допустимими типами
даних, що знижує ризик помилок у рантаймі та спрощує використання універсальностей у різних контекстах.

### 7.3 Рефлексія в Go

Рефлексія в Go - це механізм, який дозволяє програмам інспектувати і маніпулювати об'єктами в рантаймі. Це корисно для
роботи з даними, типи яких можуть бути невідомі під час компіляції. Рефлексія використовується, наприклад, для
серіалізації/десеріалізації даних, роботи з загальними API, а також у бібліотеках та фреймворках.

#### Пакет `reflect`

У Go рефлексія реалізована за допомогою пакету `reflect`. Цей пакет надає функції для роботи з типами (`reflect.Type`) і
значеннями (`reflect.Value`) об'єктів.

#### Отримання Типу та Значення

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	x := 42
	t := reflect.TypeOf(x)
	v := reflect.ValueOf(x)
	fmt.Println("Type:", t)
	fmt.Println("Value:", v)
}
```

У цьому прикладі, `reflect.TypeOf` повертає тип змінної `x`, а `reflect.ValueOf` повертає її значення. Обидва виводяться
на екран.

#### Модифікація Значень

Рефлексія також дозволяє модифікувати значення. Однак, це треба робити обережно, оскільки неправильне використання може
призвести до помилок в рантаймі.

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	x := 42
	v := reflect.ValueOf(&x).Elem() // Отримуємо reflect.Value, яке можна модифікувати
	v.SetInt(43)
	fmt.Println("x:", x) // Виведе: x: 43
}
```

Тут ми отримуємо `reflect.Value`, яке можна модифікувати, використовуючи `Elem` на покажчику до `x`, і потім
встановлюємо нове значення за допомогою `SetInt`.

#### Методи Через Рефлексію

Рефлексія також дозволяє викликати методи об'єкта динамічно:

```go
package main

import (
	"fmt"
	"reflect"
)

type MyStruct struct {
	Field string
}

func (m *MyStruct) PrintField() {
	fmt.Println(m.Field)
}

func main() {
	x := MyStruct{"Hello"}
	v := reflect.ValueOf(&x)
	m := v.MethodByName("PrintField")
	m.Call(nil)
}
```

У цьому прикладі, `MethodByName` використовується для отримання методу `PrintField`, який потім викликається за
допомогою `Call`.

#### Обмеження Рефлексії

Хоча рефлексія є потужним інструментом, вона повинна використовуватися обережно. Надмірне використання рефлексії може
зробити код важким для розуміння та підтримки. Крім того, рефлексія може бути менш продуктивною в порівнянні з прямим
використанням типів і методів.

### 7.4 Рефлексія та Універсальність: Практичний Приклад

Рефлексія та універсальності (generics) в Go можуть бути використані разом для створення гнучких та потужних рішень.
Давайте розглянемо практичний приклад, де ми комбінуємо ці дві концепції для створення функції, яка може адаптуватися до
різних типів структур.

#### Завдання

Ми створимо універсальну функцію, яка виводить інформацію про поля будь-якої структури за допомогою рефлексії.

#### Крок 1: Оголошення Універсальної Функції

```go
package main

import (
	"fmt"
	"reflect"
)

// PrintStructFields виводить назви та значення полів будь-якої структури
func PrintStructFields[T any](s T) {
	val := reflect.ValueOf(s)
	if val.Kind() != reflect.Struct {
		fmt.Println("Подано не структуру")
		return
	}

	for i := 0; i < val.NumField(); i++ {
		field := val.Type().Field(i)
		value := val.Field(i)
		fmt.Printf("%v: %v\n", field.Name, value.Interface())
	}
}
```

### Крок 2: Використання Функції з Різними Структурами

```go
type Person struct {
Name string
Age  int
}

type Book struct {
Title  string
Author string
Pages  int
}

func main() {
person := Person{Name: "Аліса", Age: 30}
book := Book{Title: "Великий Гетсбі", Author: "Ф. Скотт Фіцджеральд", Pages: 180}

PrintStructFields(person)
PrintStructFields(book)
}
```

У цьому прикладі, функція `PrintStructFields` приймає універсальний параметр `T`, що може бути будь-яким типом. За
допомогою рефлексії вона перевіряє, чи є `T` структурою, та виводить інформацію про її поля.

### Результат

Виклик `PrintStructFields` з об'єктами типу `Person` та `Book` виведе інформацію про поля цих структур. Це демонструє,
як рефлексія може бути використана для інспекції типів у рантаймі, а універсальність дозволяє створювати функції, які
можуть працювати з різними типами.

Цей підхід може бути особливо корисним у ситуаціях, де вам потрібно обробляти різноманітні структури даних, не знаючи
заздалегідь їх конкретних типів.

> Будьте вкрай уважними використовуючі рефлексію, в деяких випадках це може викликати "паніку" сервіса / додатка. 
> Також це знижує продуктівність додатків та підвищує складність коду. Тому викостання рефлексії - це "крайній випадок". Де це можливо уникайте використання пакету `reflect`.