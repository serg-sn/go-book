# Опановування основами Go: Практичний посібник з освоєння мови Go
## Розділ 9: Робота з файлами та директоріями

### Розділ 9: Робота з Файлами та Директоріями

#### 1. Читання та Запис Файлів

Робота з файлами - це фундаментальна частина багатьох програм. Go надає широкі можливості для читання та запису файлів, що дозволяє легко виконувати ці операції.

##### Читання з Файлу

Для читання з файлу в Go, ви можете використовувати пакет `os` для відкриття файлу, а потім `io` або `bufio` для читання з нього.

**Приклад:**

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("file.txt") // відкриття файлу
    if err != nil {
        fmt.Println("Помилка при відкритті файлу:", err)
        return
    }
    defer file.Close() // закриття файлу після завершення роботи

    scanner := bufio.NewScanner(file) // створення нового сканера для читання файлу
    for scanner.Scan() {
        fmt.Println(scanner.Text()) // читання файлу рядок за рядком
    }

    if err := scanner.Err(); err != nil { // помилка при читанні файлу
        fmt.Println("Помилка при читанні з файлу:", err)
    }
}
```

##### Запис у Файл

Для запису у файл, ви також відкриваєте його за допомогою `os.Open`, але з використанням режиму запису. Потім використовується `bufio` або прямий запис у файл.

**Приклад:**

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Create("output.txt")
    if err != nil { // помилка при створенні файлу
        fmt.Println("Помилка при створенні файлу:", err)
        return
    }
    defer file.Close() // закриття файлу після завершення роботи

    writer := bufio.NewWriter(file) // створення буферизованого записувача
    _, err = writer.WriteString("Hello, Go!\n") // запис у файл
    if err != nil { // помилка при записі у файл
        fmt.Println("Помилка при записі у файл:", err)
        return
    }

    err = writer.Flush() // запис у файл з буферу
    if err != nil { // помилка при записі у файл
        fmt.Println("Помилка при збереженні даних у файл:", err)
    }
}
```

У цих прикладах демонструється базовий механізм читання та запису файлів у Go. Важливо завжди закривати файли після завершення роботи з ними, що зазвичай робиться за допомогою `defer`.

#### Додаткові Можливості Читання та Запису Файлів у Go

Крім вищезгаданих методів, Go пропонує ще кілька зручних функцій для роботи з файлами, таких як `os.ReadFile` та `os.WriteFile`. Також важливою є можливість позіціонування при читанні або записі у файл.

##### Використання `os.ReadFile` та `os.WriteFile`

Ці функції пропонують простий спосіб читання з файлу та запису у файл відповідно. Вони є корисними для швидкого читання або запису цілих файлів.

**Читання з файлу за допомогою `os.ReadFile`:**

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    content, err := os.ReadFile("file.txt")
    if err != nil {
        fmt.Println("Помилка при читанні файлу:", err)
        return
    }

    fmt.Println(string(content))
}
```

**Запис у файл за допомогою `os.WriteFile`:**

```go
package main

import (
    "os"
)

func main() {
    content := []byte("Hello, Go!\n")
    err := os.WriteFile("output.txt", content, 0644)
    if err != nil {
        fmt.Println("Помилка при записі у файл:", err)
    }
}
```

##### Позіціонування у Файлі

Позіціонування в файлі корисне, коли вам потрібно читати або писати дані не з початку файлу. Ви можете використовувати `file.Seek` для встановлення поточної позиції у файлі.

**Приклад використання `file.Seek`:**

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("file.txt")
    if err != nil {
        fmt.Println("Помилка при відкритті файлу:", err)
        return
    }
    defer file.Close()

    // Переміщення на 5 байтів від початку файлу
    _, err = file.Seek(5, 0)
    if err != nil {
        fmt.Println("Помилка при позіціонуванні у файлі:", err)
        return
    }

    // Читання даних після переміщення
    buffer := make([]byte, 4)
    _, err = file.Read(buffer)
    if err != nil {
        fmt.Println("Помилка при читанні з файлу:", err)
        return
    }
    fmt.Println(string(buffer))
}
```
Seek встановлює зміщення для наступного читання або запису у файл на відстань offset, яке інтерпретується відповідно до whence: 0 означає відносно початку файлу, 1 означає
відносно поточного зміщення, а 2 означає відносно кінця файлу. 
Вона повертає нове зміщення та помилку, якщо така є. Поведінка Seek у файлі, відкритому з O_APPEND, не визначена.

У цьому прикладі, `file.Seek(5, 0)` переміщує позицію читання на 5 байтів від початку файлу, а потім читає наступні 4 байти.

Ці можливості роблять роботу з файлами у Go гнучкою та ефективною, дозволяючи легко виконувати широкий спектр операцій з файловою системою.

### 2. Навігація та Маніпуляції з Директоріями

У цьому розділі ми розглянемо, як в Go виконувати різні операції з директоріями, такі як перегляд вмісту директорій, створення та видалення папок, а також перевірка властивостей файлів та директорій.

#### Перегляд Вмісту Директорії

Для перегляду вмісту директорії в Go використовується функція `ioutil.ReadDir` або `os.ReadDir` (з Go версії 1.16).

**Приклад:**

```go
package main

import (
	"fmt"
	"log"
	"os"
)

func main() {
	files, err := os.ReadDir(".")
	if err != nil {
		log.Fatal(err)
	}

	for _, file := range files {
		fmt.Println(file.Name())
	}
}
```

У цьому прикладі `ioutil.ReadDir(".")` читає вміст поточної директорії.

#### Створення Директорії

Для створення нової директорії використовується функція `os.Mkdir` або `os.MkdirAll`. `os.MkdirAll` також створює всі батьківські директорії, якщо вони не існують.

**Приклад:**

```go
package main

import (
    "os"
    "log"
)

func main() {
    path := "./newdir"
    err := os.Mkdir(path, 0755)
    if err != nil {
        log.Fatal(err)
    }
}
```

#### Видалення Директорії

Для видалення директорії використовується `os.Remove` або `os.RemoveAll`. `os.RemoveAll` також видаляє все вміст директорії.

**Приклад:**

```go
package main

import (
    "os"
    "log"
)

func main() {
    path := "./newdir"
    err := os.RemoveAll(path)
    if err != nil {
        log.Fatal(err)
    }
}
```

#### Перевірка Властивостей Файлу або Директорії

Властивості файлу або директорії можна перевірити за допомогою `os.Stat`.

**Приклад:**

```go
package main

import (
    "fmt"
    "os"
    "log"
)

func main() {
    file, err := os.Stat("file.txt")
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("Розмір файлу:", file.Size())
    fmt.Println("Чи це директорія?:", file.IsDir())
}
```

У цьому розділі ми розглянули основні операції з директоріями у Go. У наступному розділі ми розглянемо обробку помилок та найкращі практики введення/виведення файлів.

### Обробка Помилок та Найкращі Практики Введення/Виведення Файлів

Коректне введення/виведення файлів і обробка помилок є ключовими аспектами написання надійних програм на Go. У цьому розділі ми розглянемо, як ефективно управляти помилками при роботі з файлами та дотримуватися найкращих практик.

#### Обробка Помилок

Введення/виведення файлів може призводити до помилок з різних причин: файл не існує, проблеми з доступом, помилки при читанні/запису тощо. Коректна обробка цих помилок критично важлива.

**Приклад:**

```go
file, err := os.Open("file.txt")
if err != nil {
    if os.IsNotExist(err) {
        log.Fatalf("Файл не існує: %v", err)
    } else {
        log.Fatalf("Помилка при відкритті файлу: %v", err)
    }
}
defer file.Close()
```

В цьому прикладі, помилка перевіряється, щоб визначити, чи файл існує. Якщо ні, програма завершується з відповідним повідомленням.
#### Помилки в пакеті io, os

OS:
- ErrInvalid = fs.ErrInvalid // "invalid argument"
- ErrPermission = fs.ErrPermission // "permission denied"
- ErrExist      = fs.ErrExist      // "file already exists"
- ErrNotExist   = fs.ErrNotExist   // "file does not exist"
- ErrClosed     = fs.ErrClosed     // "file already closed"
  IO:
- EOF // end of file
- ErrUnexpectedEOF // unexpected EOF
- ErrNoProgress // no progress returned by some clients of a Reader when  many calls to Read have failed to return any data or error
- ErrShortWrite // write accepted fewer bytes than requested but failed to return an explicit error
- ErrShortBuffer // buffer too small to ReadFull

#### Найкращі Практики

1. **Завжди Перевіряйте Помилки:** Не ігноруйте повернуті помилки. Це допомагає виявити та виправити проблеми на ранньому етапі.

2. **Закривайте Файли:** Використовуйте `defer` для закриття файлів. Це гарантує, що файл буде закрито, навіть якщо виникне помилка під час обробки файлу.

3. **Використовуйте Буферизоване Читання/Запис:** Для підвищення продуктивності використовуйте `bufio` для читання або запису у файли.

4. **Обережно Використовуйте Відносні Шляхи:** Будьте уважні до відносних шляхів, оскільки поточний робочий каталог може змінюватися.

5. **Перевіряйте Доступ до Файлу:** Перед читанням або записом перевірте, чи є у вас відповідні права доступу до файлу.

#### Включення файлів та директорій в скомпільований файл

З Go 1.16 введено пакет `embed`, який дозволяє включати файли та директорії безпосередньо у бінарний файл вашої програми. Це корисно для створення самодостатніх програм, які містять всі необхідні ресурси, такі як HTML шаблони, конфігураційні файли, і т.д.

В наступному підрозділі ми розглянемо, як використовувати пакет `embed` для включення файлів та директорій у ваші програми на Go.

### Включення Файлів та Директорій в Скомпільований Файл. Пакет `embed`.

Пакет `embed` у Go - це потужний інструмент, що дозволяє включати файли та директорії безпосередньо у скомпільований бінарний файл вашої програми. Це може бути корисним для створення самодостатніх програм, що містять всі необхідні ресурси, такі як шаблони, конфігураційні файли, зображення, тощо.

#### Використання Пакету `embed`

Для використання `embed`, вам потрібно імпортувати пакет `embed` та використовувати директиву `//go:embed` для вказівки на файли чи директорії, які потрібно включити.

**Приклад:**

```go
package main

import (
    "embed"
    "fmt"
    "io/fs"
    "io/ioutil"
)

//go:embed hello.txt
var helloFile embed.FS

//go:embed config/*
var configDir embed.FS

func main() {
    // Читання з файлу
    data, err := fs.ReadFile(helloFile, "hello.txt")
    if err != nil {
        panic(err)
    }
    fmt.Println(string(data))

    // Перегляд вмісту директорії
    dirEntries, err := fs.ReadDir(configDir, "config")
    if err != nil {
        panic(err)
    }

    for _, entry := range dirEntries {
        if !entry.IsDir() {
            fileData, _ := fs.ReadFile(configDir, "config/"+entry.Name())
            fmt.Println(entry.Name(), ":", string(fileData))
        }
    }
}
```

У цьому прикладі ми включаємо файл `hello.txt` та всі файли у директорії `config/`. Далі ми читаємо ці файли з використанням API файлової системи `fs`.

#### Найкращі Практики

1. **Оптимізація Розміру:** Оскільки всі включені файли збільшують розмір бінарного файлу, важливо включати лише ті файли, які дійсно потрібні для вашої програми.

2. **Безпека:** Будьте обережні при включенні файлів, які містять чутливі дані, оскільки вони будуть вбудовані безпосередньо у вашу програму.

3. **Ліцензування:** Переконайтеся, що у вас є права на включення всіх файлів, особливо якщо використовуються файли третіх сторін.

Використання `embed` у Go значно спрощує розподіл ресурсів, необхідних для вашої програми, і робить процес її розгортання більш ефективним.